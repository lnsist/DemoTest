"""冒泡排序
-- 有2层循环, 外层循环决定里层循环进行对比的次数,
所有里层循环次数越来越小 -- 次数: 10, 9, 8 ... 0
因为最后的元素是已经确定是最大(小)的, 不需要进行循环对比,
将所需排序的列表进行循环, 外层循环一次
逐个的将 当前元素 和 下一个元素 进行对比,
将最大(小)放在右侧, 列表中一直循环对比,
里层循环到最后, 最后最大(小)的元素则被放在列表中的最后,
外层循环第二次, 重复操作, 知道外层循环结束, 整个列表也对比结束

1. 比较相邻的元素, 如果第一个比第二个大, 就交换它们两个
2. 对每一对相邻元素作同样的工作, 从开始第一对到结尾的最后一对, 这样在最后的元素应该会是最大的数
3. 针对所有的元素重复以上的步骤, 除了最后一个
重复步骤1~3, 直到排序完成

在[未排序列表]中两两对比, 将[最大(小)的元素]放置后面, 直到循环结束, 确定[已排序最大(小)的元素]在列表的最后

时间复杂度
最优时间复杂度:O(n) (表示遍历一次发现没有任何可以交换的元素, 排序结束)
最坏时间复杂度:O(n^2)
稳定性:稳定

date: 18-12-29 下午4:02
"""


def bubble_sort(sort_list):
    """冒泡排序
    :param sort_list: 需要排序的列表
    """

    # 循环 依次减少内层循环的次数, 因为已确定的元素放在列表尾部 -- 次数: 10, 9, 8 ... 0
    for i in range(len(sort_list) - 1, 0, -1):
        # 循环 i 次
        for j in range(i):
            # 判断当前元素 和 下一个元素的关系
            if sort_list[j] > sort_list[j + 1]:
                # 进行交换位置
                sort_list[j], sort_list[j + 1] = sort_list[j + 1], sort_list[j]


li = [54,26,93,17,77,31,44,55,20]
bubble_sort(li)
print(li)