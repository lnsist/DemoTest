"""选择排序
-- 反过来的冒泡排序, 不同之处,
里层循环开头是根据当前外层循环次数,
选择排序不会在冒泡对比的时候进行调换位置,
而是在里层循环对比前, 记录当前需排序的坐标元素,
在里层循环比对 当前排序坐标元素 和 列表中的元素时,
记录最大(小)值的下标, 等里层循环结束, 确定了最大(小)的下标,
最后进行元素位置调换, 一般是调换到队列的开头,

初始状态: 无序区为R[1..n], 有序区为空,
第i趟排序(i=1,2,3…n-1)开始时, 当前有序区和无序区分别为R[1..i-1]和R(i..n),
该趟排序从当前无序区中-选出关键字最小的记录 R[k], 将它与无序区的第1个记录R交换,
使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区,
n-1趟结束, 数组有序化了

默认有一个空的[已排序列表]和[未排序列表], 循环[未排序列表]的[每个元素]和[已排序列表]的[最后一个元素]两两对比,
将[最大(小)的元素下标]记录下来, 循环结束, 将[最大(小)的元素]追加到已排序列表的后面

时间复杂度
最优时间复杂度:O(n^2)
最坏时间复杂度:O(n^2)
稳定性:不稳定(考虑升序每次选择最大的情况)

date: 18-12-29 下午4:19
"""


def selection_sort(sort_list):
    """选择排序"""

    # 获取需排序列表的长度
    sort_list_length = len(sort_list)
    # 循环 列表长度
    for i in range(sort_list_length - 1):
        # 当前排序下标 赋值为 当前循环次数
        sort_index = i
        # 循环, 从i + 1位置开始, 直到列表长度
        for j in range(i + 1, sort_list_length):
            # 判断 i元素 和 j元素 关系( 大于 或 小于 )
            if sort_list[j] < sort_list[sort_index]:
                # 排序下标更新
                sort_index = j
        # 如果 排序下标有变化
        if sort_index != i:
            # i元素, j元素 交换位置
            sort_list[i], sort_list[sort_index] = sort_list[sort_index], sort_list[i]


lst = [54, 226, 93, 17, 77, 31, 44, 55, 20]
selection_sort(lst)
print(lst)
